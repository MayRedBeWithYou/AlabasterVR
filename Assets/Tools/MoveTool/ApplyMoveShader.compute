// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct MoveData
{
    uint3 from;
    float value;
    float avg;
};

struct DebugOutData
{
    uint3 from;
    uint3 to;
    float value;
};

AppendStructuredBuffer<DebugOutData> debugBuffer;

RWStructuredBuffer<float> sdf;
StructuredBuffer<MoveData> workBuffer;

float spacing;
float3 offset;
uint resolution;
StructuredBuffer<uint> entries;


uint coords(uint3 id)
{
    return id.z * resolution * resolution + id.y * resolution + id.x;
}

[numthreads(512, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x < entries[0])
    {
        MoveData data;
        data = workBuffer[id.x];
        uint3 targetId = id;
        //uint3 targetId2;
        //float dist = length(offset);
        //float3 foo = float3(spacing, spacing, spacing);
        //float fooDist = length(foo);
        //float t = offset / fooDist;
        
        //god code to jest dobre
        //targetId.x = data.from.x + floor(offset.x / spacing);
        //targetId.y = data.from.y + floor(offset.y / spacing);
        //targetId.z = data.from.z + floor(offset.z / spacing);
        
        
        //targetId2.x = data.from.x + ceil(offset.x / spacing);
        //targetId2.y = data.from.y + ceil(offset.y / spacing);
        //targetId2.z = data.from.z + ceil(offset.z / spacing);
        //sdf[coords(data.from)] = 1.0f;
        
        
        //sdf[coords(targetId)] = data.value;// * t;
        
        
        //sdf[coords(targetId2)] = data.value * (1-t);
        sdf[coords(data.from)] = data.avg;
        DebugOutData outData;
        outData.from = data.from;
        outData.to = targetId;
        outData.value = data.value;
        debugBuffer.Append(outData);
    }
    //sdf[id.x] = -1.0f;
}
