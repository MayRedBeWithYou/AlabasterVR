// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel PopulateWorkBuffer
#pragma kernel ApplySmooth

struct MoveData
{
    uint3 from;
    float value; //#todo remove this, not needed anymore
    float avg;
};

RWStructuredBuffer<float> sdf;
AppendStructuredBuffer<MoveData> appendWorkBuffer;
StructuredBuffer<MoveData> structuredWorkBuffer;
StructuredBuffer<uint> entries;

uint resolution;

float chunkSize;
float toolRadius;
float3 toolCenter;


uint coords(uint3 id)
{
    return id.z * resolution * resolution + id.y * resolution + id.x;
}

float3 realPos(uint3 id)
{
    float3 ids = id;
    float res = resolution - 1;
    ids = id / res;
    return ids * chunkSize;
}

[numthreads(8, 8, 8)]
void PopulateWorkBuffer(uint3 id : SV_DispatchThreadID)
{
    float3 displacement = realPos(id) - toolCenter;
    float val = dot(displacement, displacement) - (toolRadius * toolRadius);
    if (val < 0) //inside cursor
    {
        MoveData data;
        data.from = id;
        data.value = sdf[coords(id)];

        float avg = 0;
        avg += sdf[coords(uint3(id.x + 1, id.y, id.z))];
        avg += sdf[coords(uint3(id.x - 1, id.y, id.z))];
        avg += sdf[coords(uint3(id.x, id.y + 1, id.z))];
        avg += sdf[coords(uint3(id.x, id.y - 1, id.z))];
        avg += sdf[coords(uint3(id.x, id.y, id.z - 1))];
        avg += sdf[coords(uint3(id.x, id.y, id.z + 1))];
        avg = avg / 6;
        data.avg = avg;
        appendWorkBuffer.Append(data);
    }
}

[numthreads(512, 1, 1)]
void ApplySmooth(uint3 id : SV_DispatchThreadID)
{
    if (id.x < entries[0])
    {
        MoveData data;
        data = structuredWorkBuffer[id.x];
        sdf[coords(data.from)] = data.avg;
    }
}

